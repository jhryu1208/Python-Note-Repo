"""
v1 == v2 : 변수 v1과 v2가 참조하는 "객체의 내용"이 동일한가?
v1 is v2 : 변수 v1과 v2가 참조하는 객체는 "동일 객체"인가?
"""

v1 = [1, 2, 3]
v2 = [1, 2, 3]

print(f'v1 == v2 : {v1 == v2}') # v1와 v2가 지니고 있는 value는 동일하다.
print(f'v1 is v2 : {v1 is v2}') # 하지만, v1과 v2가 지니고 있는 list는 동일 객체가 아니다.
print(f'v1의 주소 : {id(v1)}, v2의 주소 : {id(v2)}') # 두 리스트의 주소가 다름을 확인하여 알 수 있다.

print('\n')


"""
얕은 복사 : 복사했다고 생각했지만 실제로는 변수가 동일 값을 참조하고 있는 것
깊은 복사 : 깊은 복사는 내부에 객체들까지 모두 새롭게 copy 되어 서로 다른 객체를 참조하고 있는 것
"""

r1 = ['string', (1, 2), [100, 200]]
r2 = r1 # r1이 참조하고 있는 리스트를 r2도 참조하게됨 (리스트의 레퍼런스 카운트 1증가)
r3 = list(r1) # r1이 참조하고 있는 리스트의 내용으로 새로운 리스트를 생성함 (즉, r2와 달리 참조하지 않음)

"""
아래의 반복문의 출력 결과는 다음과 같다.
r2와 r1의 주소가 동일하며, 새롭게 생성된 케이스인 r3의 경우 다른 주소 값을 가지고 있다.
하지만, "r1, r2, r3가 가지고 있는 list요소들의 주소가 모두 동일"한 것을 확인할 수 있다.

왜냐하면, list내부의 각 요소들이 각 값들을 참조하는 형태를 이루기 때문이다.
즉, r1[0]는 'string'을 참조하고,
r1[1]은 (1, 2)를 참조하고,
r1[2]는 [100, 200]을 참조하는 것이다.

따라서, r3라는 리스트 객체가 새로 생성되었을 뿐이지,
list 내부의 원소들은 기존의 값들을 모두 참조하고 있는 것이다.
이러한 형태의 복사를 "얕은 복사"라고 칭한다.

['string', (1, 2), [100, 200]] : 3174767474568
string : 3174767552240
(1, 2) : 3174762881288
[100, 200] : 3174762924296

['string', (1, 2), [100, 200]] : 3174767474568
string : 3174767552240
(1, 2) : 3174762881288
[100, 200] : 3174762924296

['string', (1, 2), [100, 200]] : 3174768339784
string : 3174767552240
(1, 2) : 3174762881288
[100, 200] : 3174762924296
"""
for r in [r1, r2, r3]:
    print(f'{r} : {id(r)}')
    for e in r:
        print(f'{e} : {id(e)}')
    print('\n')


print('\n')

"""
위와 같은 얕은 복사는 튜플이나 문자열 객체와 같은 immutable 객체에게는 문제가 없다.
하지만, 원본 데이터를 유지하는 상황이 필요할 수 있는 list와 같은 mutable객체에서는 문제가될 수 있다.
따라서, 이러한 문제를 회피하기 위해서 "깊은 복사"를 수행해야한다.
"""

r1[1] += (1, 2)
r1[2] += [1, 2]
print(f'r1 : {r1}\nr2 : {r2}\nr3 : {r3}')
# immutable객체인 tuple의 경우 문제없지만,
# mutable객체인 원본값의 r[2](list)는 원본 list까지 포함하여 모든 list의 값이 변화하였다.

print('\n')

"""
깊은복사는 mutable객체의 복사 대상을 하나 더 생성시킨다.
그리고, copy 모듈의 deepcopy함수를 사용하여 구현한다.
"""

import copy

d1 = copy.deepcopy(r1)
print(f'd1의 주소 : {id(d1[2])}\nr1의 주소 : {id(r1[2])}') #서로 주소가 다른 것을 확인
print(f'd1[2] == r1[2] : {d1[2] == r1[2]}')
print(f'd1[2] is r1[2] : {d1[2] is r1[2]}')
